{
  "articles": [
    {
      "id": 3616810700,
      "title": "JavaScript 中的数据拷贝指南 🧭",
      "slug": "javascript-copy",
      "excerpt": "在 JavaScript 编程中，数据的复制是一个基础而又至关重要的概念，尤其在处理复杂的数据结构时，正确地执行拷贝操作可以避免意料之外的数据修改问题...",
      "content": "> 发布时间：2025-08-24  \n> 分类：前端开发 > JavaScript.js  \n> 标签：JavaScript, 数据拷贝, 前端开发\n\n## 引言\n\n在 JavaScript 编程中，数据的复制是一个基础而又至关重要的概念，尤其在处理复杂的数据结构时，正确地执行拷贝操作可以避免意料之外的数据修改问题\n\n## 浅拷贝与深拷贝的区别\n\n在 JavaScript 中，数据拷贝通常指的是对象或数组的复制。根据是否进行深层次的复制，可以分为浅拷贝和深拷贝。\n\n### 浅拷贝\n\n浅拷贝只会复制对象的第一层属性。如果属性值是基本数据类型（如数字、字符串、布尔值等），则复制的是值；如果属性值是对象或数组（即引用类型），则复制的是引用（即指针），而不是对象本身。\n\n### 深拷贝\n\n深拷贝会递归复制对象的所有层级，创建一个完全独立的副本。这意味着原始对象和拷贝对象没有任何共享的引用。\n\n深拷贝确保对象的每个属性都是新创建的，修改拷贝对象不会影响原始对象\n\n## 浅拷贝的常用方法\n\n### Object.create\n\n新对象的原型被设置为原对象\n\n```javascript\nconst original = {\n  name: 'John',\n  age: 30,\n  address: {\n      city: 'New York',\n      zip: '10001'\n}\nconst newObj = Object.create(original)\nconsole.log(newObj, 'newObj')\n```\n\n### Object.assign\n\n```javascript\nconst original = {\n  name: 'John',\n  age: 30,\n  address: {\n      city: 'New York',\n      zip: '10001'\n},\nconst newObj = Object.assign({}, original)\nconsole.log(newObj, 'newObjg')\n```\n\n### 展开运算符\n\n```javascript\nconst original = {\n  name: 'John',\n  age: 30,\n  address: {\n      city: 'New York',\n      zip: '10001'\n},\nconst newObj = {...original}\nconsole.log(newObj, 'newObjg')\n```\n\n## 深拷贝的常用方法\n\n### **JSON.parse(JSON.stringify(obj))**\n\n1：无法识别 BigInt 类型： 当对象中包含 BigInt 类型的值时，这个方法会将其转换为字符串，因为 JSON 标准不支持 BigInt 类型。因此，复制后的对象中的 BigInt 值不再是 BigInt，而是字符串。\n\n2：无法拷贝 undefined、function、Symbol 属性：\n\n（1）：undefined 的属性值会被忽略，因为它不是 JSON 格式的一部分。\n\n（2）：函数（function）作为对象的属性不能被序列化，所以在解析后会丢失。\n\n（3）：Symbol 作为键或值同样不会被处理，因为 JSON.stringify 会忽略 Symbol 类型的键，且 Symbol 值也不能被直接序列化。\n\n3：无法处理循环引用： 如果对象结构中存在循环引用（即对象 A 的某个属性引用了对象 B，同时对象 B 的某个属性又引用了对象 A），JSON.stringify 会抛出错误，因为它无法正确地序列化这样的结构。\n\n```javascript\nlet obj = {\n    a: 3,\n    b: { n: 2 },\n    c: 'ccccc',\n    d: true,\n    e: undefined,\n    f: null,\n    g: function () {},\n    h: Symbol(1)\n}\n\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj) //{ a: 3, b: { n: 2 }, c: 'ccccc', d: true, f: null }\nobj.b.n = 1\nconsole.log(newObj) //{ a: 3, b: { n: 2 }, c: 'ccccc', d: true, f: null }\n//实现了深度拷贝，但是没有拷贝`undefined`、`function`、`Symbol`\n```\n\n**不能被 json 序列化的，都不支持**\n\n### **structuredClone(obj)**\n\n是一个较新的 API（在某些现代浏览器和 Node.js 中可用），它能完美地克隆大多数值，包括循环引用，但兼容性可能不是那么好。\n\n```javascript\nlet obj = {\n    a: 1,\n    b: { n: 1 }\n}\n\nconst newObj = structuredClone(obj)\nobj.b.n = 3\nconsole.log(newObj) //{ a: 1, b: { n: 1 } }\n```\n\n### 手写一个深拷贝方法\n\n支持大部分场景\n\n```javascript\nconst deepCopy = obj => {\n    if (obj !== null || typeof obj !== 'object') {\n        //排出这两类类型直接return\n        return obj\n    }\n    //如果是数组\n    if (obj instanceof Array) {\n        const copy = []\n        obj.forEach(item => copy.push(item))\n        return copy\n    }\n    //如果是日期\n    if (obj instanceof Date) {\n        return new Date(obj)\n    }\n    //如果是对象\n    if (obj instanceof Object) {\n        const copy = {}\n        Object.kyes(obj).forEach(key => {\n            copy[key] = deepCopy(obj[key])\n        })\n        return copy\n    }\n    throw new Error('报错！！')\n}\nconst obj = {\n    name: '张三',\n    age: 18,\n    getInfo: () => {},\n    info: {\n        a: '1',\n        b: { b: 2 },\n        c: true\n    },\n    time: new Date(),\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n}\nconst newObj = deepCopy(obj)\nconsole.log(newObj, 'obj-->>')\n```\n\n## 总结\n\n-   **浅拷贝：复制对象的第一层属性，嵌套的对象或数组共享引用。**\n\n-   **深拷贝：递归复制对象的所有层级，创建完全独立的副本。**\n",
      "categoryId": 1,
      "categorySlug": "frontend",
      "categorySlugs": [
        "frontend"
      ],
      "tags": [
        "JavaScript",
        "数据拷贝",
        "前端开发"
      ],
      "author": "admin",
      "publishDate": "2025-08-24T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.616Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/javascript-copy-cover.jpg"
    },
    {
      "id": 1823977704,
      "title": "JavaScript Woker 多线程",
      "slug": "javascript-worker",
      "excerpt": "JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。...",
      "content": "> 发布时间：2024-05-20  \n> 分类：前端开发 > JavaScript  \n> 标签：JavaScript, Worker, 前端开发\n\n## 前言\n\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\n\n## worker 是什么\n\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\n\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭\n\n## worker 的方法\n\n```plain\nvar worker = new Worker('work.js');\n```\n\n1. **worker.postMessage() 子线程与主线程通信方式，可以向主线程推送消息**\n\n1. **worker.onmessage()定监听函数，接收子线程发回来的消息**\n\n1. **worker.terminate() 关闭线程方式， 线程用完或者，不需要 可以直接关闭线程，防止资源浪费**\n\n1. **postMessage() 或 self.postMessage() 向主线程推送消息，主线程用 onmessage 接收**\n\n## **worker 如何使用**\n\n**下面是在 react 里面的用法，基本上别的也都大差不差**\n\n1. **首先创建一个 worler.js， 内容为**\n\n```plain\nconst workercode = () => {\n  self.onmessage = (e)=>{\n   \n  }\n};\n// 把脚本代码转为string\nlet code = workercode.toString();\ncode = code.substring(code.indexOf(\"{\")+1, code.lastIndexOf(\"}\"));\n \nconst blob = new Blob([code], {type: \"application/javascript\"});\nconst worker_script = URL.createObjectURL(blob);\n \nmodule.exports = worker_script;\n```\n\n**self.onmessage 方法里面可以写你自己想写的业务逻辑，比如你想把哪些代码新开一个线程，就写进来，也可以发起请求等, 通过 postMessage 想调用的主线程传参数**\n\n**注意:**\n\n**看代码里面出现了一个 self，有可能会很疑惑，我并没有定义这个 self，代码运行起来不会出现报错无法运行吗？**\n\n**这里是不会出现报错或者代码运行不起来的，因为在 worker 里面，是没有 window 全局实例的，this 也没有，使用 this 在本地可以，打包之后就找不到 this 了(自己测试出现的情况);**\n\n**所以在 worker 里面 self 才是他的全局对象**\n\n**如果出现 self 报错，代码无法运行的情况或者出现一下情况**\n\n![图片](/content/assets/images/javascript-worker-1-986f5371.png)\n**这个时候代码是会报错的**\n\n**解决办法：**\n\n因为这个是 eslint 规则报的错误，本人目前也是直接先给禁用掉了，在代码前加上这句话\n\n// eslint-disable-next-line no-restricted-globals\n\n1. **在主线程使用 worker(主线程是指，你的业务代码，或者你那里需要用的时候)**\n\n首先引入然后 new 实例化\n\nimport worker_script from './worker';\n\nvar myWorker = new Worker(worker_script);\n\n![图片](/content/assets/images/javascript-worker-2-35ab7130.png)\n我这里是在我 APP.js 里面使用 worker 的，就相当于主线程\n\n然后通过\n\n![图片](/content/assets/images/javascript-worker-3-b0dc285a.png)\n\n通过 myWorker.postMessage()方法来调用子线程,可以传入你想传入的参数\n\n这个时候子线程 worker.js 里就可以拿到你传入的值了\n\n![图片](/content/assets/images/javascript-worker-4-5cbd840e.png)\n\n然后做完你想做的处理通过 postMessage()在给主线程返回过去，这个返回不返回都行，看你自己的业务\n\n主线程通过 onmessage 来实时获取到子线程那边返回过来的值\n\n```plain\n  myWorker.onmessage = (e) => {\n\n  };\n```\n\n示例:\n\n![图片](/content/assets/images/javascript-worker-5-4c4d0f16.png)\n",
      "categoryId": 1,
      "categorySlug": "frontend",
      "categorySlugs": [
        "frontend",
        "javascript"
      ],
      "tags": [
        "JavaScript",
        "Worker",
        "前端开发"
      ],
      "author": "admin",
      "publishDate": "2024-05-20T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.625Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/javascript-worker-cover.jpg"
    },
    {
      "id": 3229293222,
      "title": "React Hooks 完全指南",
      "slug": "react-hooks-guide",
      "excerpt": "React Hooks 是 React 16.8 引入的新特性，它允许你在不编写 class 的情况下使用 state 以及其他的 React 特性。本文将详细介绍 React Hooks 的使用方法和最佳实践。...",
      "content": "> 发布时间：2024-01-20  \n> 分类：前端开发 > React  \n> 标签：React, Hooks, 前端开发\n\n## 前言\n\nReact Hooks 是 React 16.8 引入的新特性，它允许你在不编写 class 的情况下使用 state 以及其他的 React 特性。本文将详细介绍 React Hooks 的使用方法和最佳实践。\n\n## 什么是 Hooks？\n\nHooks 是一些可以让你在函数组件里\"钩入\" React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用，但可以让你在不写 class 的情况下使用 React。\n\n## 常用的 Hooks\n\n### 1. useState\n\n用于在函数组件中添加状态：\n\n```jsx\nimport React, { useState } from 'react'\n\nfunction Counter() {\n    const [count, setCount] = useState(0)\n\n    return (\n        <div>\n            <p>你点击了 {count} 次</p>\n            <button onClick={() => setCount(count + 1)}>点击我</button>\n        </div>\n    )\n}\n```\n\n### 2. useEffect\n\n用于执行副作用操作：\n\n```jsx\nimport React, { useState, useEffect } from 'react'\n\nfunction Example() {\n    const [count, setCount] = useState(0)\n\n    useEffect(() => {\n        document.title = `你点击了 ${count} 次`\n    })\n\n    return (\n        <div>\n            <p>你点击了 {count} 次</p>\n            <button onClick={() => setCount(count + 1)}>点击我</button>\n        </div>\n    )\n}\n```\n\n### 3. useContext\n\n用于使用 Context：\n\n```jsx\nimport React, { useContext } from 'react'\n\nconst ThemeContext = React.createContext()\n\nfunction Button() {\n    const theme = useContext(ThemeContext)\n    return <button style={{ background: theme.background, color: theme.foreground }}>我是一个按钮</button>\n}\n```\n\n## 自定义 Hooks\n\n你可以创建自定义 Hooks 来复用状态逻辑：\n\n```jsx\nimport { useState, useEffect } from 'react'\n\nfunction useCounter(initialValue = 0) {\n    const [count, setCount] = useState(initialValue)\n\n    const increment = () => setCount(count + 1)\n    const decrement = () => setCount(count - 1)\n    const reset = () => setCount(initialValue)\n\n    return { count, increment, decrement, reset }\n}\n\n// 使用自定义 Hook\nfunction Counter() {\n    const { count, increment, decrement, reset } = useCounter(10)\n\n    return (\n        <div>\n            <p>计数: {count}</p>\n            <button onClick={increment}>+</button>\n            <button onClick={decrement}>-</button>\n            <button onClick={reset}>重置</button>\n        </div>\n    )\n}\n```\n\n## 最佳实践\n\n1. **只在最顶层使用 Hook**：不要在循环、条件或嵌套函数中调用 Hook\n2. **只在 React 函数中调用 Hook**：不要在普通的 JavaScript 函数中调用 Hook\n3. **使用 eslint-plugin-react-hooks**：这个插件可以帮助你遵循 Hook 规则\n4. **合理拆分 useEffect**：将不相关的逻辑分离到不同的 Effect 中\n\n## 总结\n\nReact Hooks 为函数组件提供了强大的能力，让我们可以在不使用 class 的情况下使用 React 的各种特性。掌握 Hooks 是现代 React 开发的必备技能。\n\n---\n\n_更多 React 开发技巧，请关注我们的技术博客。_\n",
      "categoryId": 1,
      "categorySlug": "frontend",
      "categorySlugs": [
        "frontend",
        "react"
      ],
      "tags": [
        "React",
        "Hooks",
        "前端开发"
      ],
      "author": "admin",
      "publishDate": "2024-01-20T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.629Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/react-hooks-guide-cover.jpg"
    },
    {
      "id": 453305820,
      "title": "前端 CICD 自动部署",
      "slug": "-cicd",
      "excerpt": "每次部署项目时，手动将文件拷贝到服务器不仅繁琐，还容易出错。因此，我决定学习如何进行前端全自动部署。我的目标是让部署过程更加便捷高效，只需提交代码，服务器就能自动更新，这样可以大大节省时间，提高工作效率。...",
      "content": "> 发布时间：2024-01-20  \n> 分类：前端开发 > React  \n> 标签：CICD, 服务器, 部署\n\n## 前言\n\n每次部署项目时，手动将文件拷贝到服务器不仅繁琐，还容易出错。因此，我决定学习如何进行前端全自动部署。我的目标是让部署过程更加便捷高效，只需提交代码，服务器就能自动更新，这样可以大大节省时间，提高工作效率。\n\n在开始学习前端自动部署之前，建议你提前了解一些基础的服务器知识。虽然不需要深入掌握所有命令(命令可以百度或者问 AI)，但熟悉常见的服务器操作和部署流程会让你在遇到问题时更加从容。可以在遇到具体问题时通过百度等 AI 工具查找相关命令和解决方案。这样，在实现自动部署的过程中，你不仅能更高效地完成部署工作，还能逐步积累服务器管理的经验，为后续的自动化部署打下坚实的基础\n\n```plain\n将网站一键部署到服务器的方案很多，比如纯Shell脚本结合SSH、Jenkins等工具。本文将介绍如何利用GitHub Actions这一免费且轻量的CI/CD工具，实现代码推送后自动部署到云服务器\n```\n\n## 准备工作\n\n-   需要有自己的服务器，我的是阿里云的服务器\n\n-   创建一个代码存储库(我的是 github)\n\n-   项目类型：静态网站、及 node 服务\n\n## ssh 密钥配置\n\n#### 服务器端配置\n\n在服务器实例连接后操作\n\n-   **生成 SSH 密钥对**（如果已有可跳过）：\n\n```bash\n# 生成密钥对（默认保存到 ~/.ssh/）\nssh-keygen -t ed25519 -C \"github-actions\"\n```\n\n-   **将公钥添加到服务器的**`authorized_keys`\n\n```bash\ncat ~/.ssh/id_ed25519.pub >> ~/.ssh/authorized_keys\nchmod 600 ~/.ssh/authorized_keys //设置权限\n```\n\n-   **确保服务器 SSH 配置允许密钥登录**（检查  `/etc/ssh/sshd_config`）:\n\n```plain\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n\n登录服务器，打开 SSH 配置文件（通常为  `/etc/ssh/sshd_config`）：\n\n```bash\nsudo vim /etc/ssh/sshd_config  # 或使用 nano\n```\n\n确保以下参数已正确设置：\n\n```bash\n# 启用密钥认证\nPubkeyAuthentication yes\n\n\n# 公钥文件路径（默认值一般无需修改）\nAuthorizedKeysFile .ssh/authorized_keys\n\n\n# 可选：禁用密码登录（提高安全性）\nPasswordAuthentication no\n```\n\n如果没有，自行设置一下 按 i 编辑，编辑完按下 esc 然后:wq 回车保存\n\n## ssh-配置验证\n\nSSH 对文件权限非常敏感，需确保以下权限正确：\n\n1. **验证文件权限**\n\n#### `.ssh`**目录权限**\n\n```bash\n# 用户目录下的 .ssh 文件夹权限\nchmod 700 ~/.ssh\n```\n\n#### `authorized_keys`**文件权限**\n\n```bash\nchmod 600 ~/.ssh/authorized_keys\n```\n\n1. **重启 SSH 服务**\n\n修改配置后，重启 SSH 服务使配置生效：\n\n```plain\n# Ubuntu/Debian\nsudo systemctl restart ssh\n\n\n# CentOS/RHEL\nsudo systemctl restart sshd\n```\n\n1. **测试密钥登录**\n\n从你的本地机器(服务器面板)测试是否能通过密钥登录服务器：\n\n```plain\nssh -i ~/.ssh/你的私钥文件 username@服务器IP -p 端口\n```\n\n你的私钥文件：就是你创建密钥的文件名称\nusername@服务器 ip：服务器用户名+ip 中间@隔开\n\n端口：默认的 ssh 端口为 22\n\n如果失败，可添加  `-v`  参数查看详细日志\n\n成功了会提示\n\n```bash\nWelcome to Alibaba Cloud Elastic Compute Service !\n```\n\n#### GitHub 仓库配置\n\n-   进入仓库的  **Settings > Secrets and variables > Actions**，添加以下 Secrets：\n\n    -   `SERVER_IP`: 服务器 IP 地址（如  `123.123.123.123`） //就是你服务器的公网 ip\n\n    -   `SSH_PORT`: SSH 端口（默认  `22`）\n\n    -   `SSH_USERNAME`: SSH 登录用户名（如  `root`）\n\n    -   `SSH_PRIVATE_KEY`: 服务器的私钥内容（`id_ed25519`  文件内容）\n\n| 命令              | 解释                                         |\n| :---------------- | :------------------------------------------- |\n| cat ~/.ssh/id_rsa | 查看私钥命令 id_rsa 替换为你生成的密钥文件名 |\n\n## GitHub-actions-工作流配置\n\n### 基本配置\n\n在项目根目录创建  `.github/workflows/deploy.yml`  文件，或者点击仓库上方的 action ，随便点击一个模版创建一个也行，然后创建一下 deploy.yml 文件\n\n这是我的 yml 文件，可以进行参考，这是我前端 vue 项目的，当然你也可以让 AI 帮你写一份都是可以的，不过这里面坑挺多，我身为前端懂得也不多，只能慢慢摸索\n\n这里有一些文档[https://docs.github.com/zh/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions](https://docs.github.com/zh/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions)\n\n```yaml\nname: 部署到服务器\n\n\non:\n    push:\n        branches: ['main']\n\n\njobs:\n    deploy:\n        runs-on: ubuntu-latest\n\n\n        steps:\n            - name: 检出代码\n              uses: actions/checkout@v4\n\n\n            - name: 调试-列出仓库文件\n              run: ls -la $GITHUB_WORKSPACE\n\n\n            - name: 配置SSH环境\n              run: |\n                  mkdir -p ~/.ssh\n                  chmod 700 ~/.ssh\n                  echo \"${{ secrets.SSH_PRIVATE_KEY }}\" | tr -d '\\r' > ~/.ssh/github_actions_key\n                  chmod 600 ~/.ssh/github_actions_key\n                  ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts\n\n\n            - name: 安装Rsync工具\n              run: sudo apt-get update && sudo apt-get install -y rsync\n\n\n            - name: 构建项目（适配pnpm/npm）\n              working-directory: vue-blog-project\n              run: |\n                  npm install -g pnpm\n                  pnpm install\n                  rm -rf node_modules/.vite\n                  pnpm run build\n\n\n            - name: 调试-显示构建产物\n              run: ls -la vue-blog-project/dist\n\n\n            - name: 设置服务器同步参数\n              run: |\n                  mkdir -p ~/.ssh\n                  chmod 700 ~/.ssh\n                  echo \"${{ secrets.SSH_PRIVATE_KEY }}\" | tr -d '\\r' > ~/.ssh/github_actions_key\n                  chmod 600 ~/.ssh/github_actions_key\n                  ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts\n\n\n            - name: 同步构建文件到服务器\n              run: |\n                  rsync -avz --progress --delete \\\n                    --exclude='node_modules' \\\n                    --exclude='.git' \\\n                    --exclude='.DS_Store' \\\n                    -e \"ssh -i ~/.ssh/github_actions_key -o StrictHostKeyChecking=no -p ${{ secrets.SSH_PORT }}\" \\\n                    ./vue-blog-project/dist/ \\\n                    ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_IP }}:/www/wwwroot/default/\n```\n\n配置完这个文件之后，就可以进行提交代码，然后点击 action 进行测试啦，会看到执行到哪一个步骤了\n\n我这个采用的是，通过 rsync 来进行同步到服务器静态文件，install 下载完包之后，然后进行构建，构建完成之后会把 dist 文件同步发到我相应的服务器网站上，网站是对应文件夹的(操作过服务器的知道)\n\n### 不是静态文件的情况下\n\n有一些项目不是这种静态文件的，可能是服务端、就比如 node.js 、我这个是 egg\n\n是需要使用 pm2 进行监管的。那么就需要改一下 yml 文件了\n\n```yaml\nname: 部署到服务器\n\n\non:\n    push:\n        branches: ['main']\n\n\njobs:\n    deploy:\n        runs-on: ubuntu-latest\n\n\n        steps:\n            - name: 检出仓库代码\n              uses: actions/checkout@v4\n\n\n            - name: 设置SSH环境\n              run: |\n                  mkdir -p ~/.ssh\n                  chmod 700 ~/.ssh\n                  echo \"${{ secrets.SSH_PRIVATE_KEY }}\" | tr -d '\\r' > ~/.ssh/github_actions_key\n                  chmod 600 ~/.ssh/github_actions_key\n                  ssh-keyscan -p ${{ secrets.SSH_PORT }} ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts\n\n\n            - name: 安装Rsync工具\n              run: sudo apt-get update && sudo apt-get install -y rsync\n\n\n            - name: 同步文件到服务器\n              run: |\n                  rsync -avz --progress \\\n                    --exclude='.git' \\\n                    --exclude='.github/' \\\n                    --exclude='node_modules/' \\\n                    --exclude='*.log' \\\n                    -e \"ssh -i ~/.ssh/github_actions_key -o StrictHostKeyChecking=no -p ${{ secrets.SSH_PORT }}\" \\\n                    $GITHUB_WORKSPACE/ \\\n                    ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_IP }}:/www/wwwroot/egg-blog/ \\\n                    || echo \"忽略非关键错误\"\n\n\n            - name: 停止并启动应用服务\n              run: |\n                  ssh -i ~/.ssh/github_actions_key -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_IP }} <<EOF\n                  # 停止服务\n                  cd /www/wwwroot/egg-blog && npm stop || echo \"停止服务失败，可能服务未运行\"\n\n\n                  # 启动服务\n                  cd /www/wwwroot/egg-blog && nohup npm start > /dev/null 2>&1 &\n                  EOF\n\n\n            - name: 调试-列出目标目录文件\n              run: |\n                  ssh -i ~/.ssh/github_actions_key -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SERVER_IP }} \\\n                    \"ls -la /www/wwwroot/egg-blog\"\n```\n\n加了一些操作，文件同步到服务器之后，先停止当前启动的服务，然后同步过去之后在进行重新启动。\n\n## 常见问题总结\n\n我自己操作的途中遇到了一些问题，也是很苦恼，我也给列出来\n\n1. 权限错误\n\n2. shh 密钥与服务器连接不上（大概率是权限问题导致的，要不然就是密钥错误）\n\n3. yml 文件配置问题\n\n4. SELinux 或防火墙限制\n\n这个就是防火墙及安全组的问题，如果你要用什么端口就需要去防火墙或安全组开放这个端口，要不然不可以使用\n\n### 权限问题\n\n不管是在流水线同步文件的时候 或者是执行直接就报错的时候，出现类似于\n\nPermissions 字眼，那么就是权限问题导致\n\n建议：\n\n仔细检查服务器的文件夹权限，看是否有读写权限，检查清楚操作用户是谁，是 root 还是 admin 等等，设置同步目录的权限\n\n### ssh 密钥与服务器连接不上\n\n这个要检查好你的私钥是否错误，要复制全，包括\n\n-----BEGIN OPENSSH PRIVATE KEY-----\n\n使用你自己的密钥\n-----END OPENSSH PRIVATE KEY-----\n\n这种格式\n\n另外还要记得在阿里云实例，安全组开放 22 端口，以及在服务器内部可以通过宝塔进去，然后点击安全，把 22 端口开放\n\n![图片](/content/assets/images/前端也要必备的全自动化部署cicd-1-5ba7e23f.png)\n\n### yml 文件配置问题\n\n这个是需要一定的了解，或者不断的去尝试，寻求 AI 的帮助，慢慢自己去摸索，去探索，后端或者运维对这个可能要熟悉很多，也可以查一下他的文档，\n\n如果流水线 同步文件的时候提示没权限的话，\n\n那么就去登陆服务器进去，设置一下你目录的权限为 755 或者 777，\n\n![图片](/content/assets/images/前端也要必备的全自动化部署cicd-2-40ae0f05.png)\n",
      "categoryId": 3,
      "categorySlug": "server",
      "categorySlugs": [
        "frontend",
        "react"
      ],
      "tags": [
        "CICD",
        "服务器",
        "部署"
      ],
      "author": "admin",
      "publishDate": "2024-01-20T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.635Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/前端也要必备的全自动化部署cicd-cover.jpg"
    },
    {
      "id": 967244257,
      "title": "Vue3 组合式 API 深度解析",
      "slug": "vue3-composition-api",
      "excerpt": "Vue3 的组合式 API（Composition API）是 Vue.js 框架的一次重大革新，它为开发者提供了更灵活、更强大的代码组织方式。本文将深入探讨组合式 API 的核心概念和实际应用。...",
      "content": "> 发布时间：2024-01-15  \n> 分类：前端开发 > Vue  \n> 标签：Vue3, Composition API, JavaScript\n\n## 前言\n\nVue3 的组合式 API（Composition API）是 Vue.js 框架的一次重大革新，它为开发者提供了更灵活、更强大的代码组织方式。本文将深入探讨组合式 API 的核心概念和实际应用。\n\n## 什么是组合式 API？\n\n组合式 API 是一套基于函数的 API，允许我们更好地组织组件逻辑。相比于选项式 API，它提供了：\n\n-   更好的类型推导\n-   更灵活的代码复用\n-   更清晰的逻辑组织\n\n## 核心概念\n\n### 1. setup() 函数\n\n`setup()` 是组合式 API 的入口点：\n\n```javascript\nimport { ref, reactive } from 'vue'\n\nexport default {\n    setup() {\n        // 响应式数据\n        const count = ref(0)\n        const state = reactive({\n            name: 'Vue3',\n            version: '3.x'\n        })\n\n        // 方法\n        const increment = () => {\n            count.value++\n        }\n\n        // 返回模板使用的数据和方法\n        return {\n            count,\n            state,\n            increment\n        }\n    }\n}\n```\n\n### 2. ref() 和 reactive()\n\n-   `ref()`: 创建基本类型的响应式引用\n-   `reactive()`: 创建对象的响应式代理\n\n```javascript\n// ref 用于基本类型\nconst count = ref(0)\nconst message = ref('Hello Vue3')\n\n// reactive 用于对象\nconst user = reactive({\n    id: 1,\n    name: 'John',\n    email: 'john@example.com'\n})\n```\n\n### 3. 计算属性和侦听器\n\n```javascript\nimport { ref, computed, watch } from 'vue'\n\nexport default {\n    setup() {\n        const firstName = ref('John')\n        const lastName = ref('Doe')\n\n        // 计算属性\n        const fullName = computed(() => {\n            return `${firstName.value} ${lastName.value}`\n        })\n\n        // 侦听器\n        watch(firstName, (newValue, oldValue) => {\n            console.log(`名字从 ${oldValue} 变为 ${newValue}`)\n        })\n\n        return {\n            firstName,\n            lastName,\n            fullName\n        }\n    }\n}\n```\n\n## 生命周期钩子\n\n在组合式 API 中，生命周期钩子需要显式导入：\n\n```javascript\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\n\nexport default {\n    setup() {\n        onMounted(() => {\n            console.log('组件已挂载')\n        })\n\n        onUpdated(() => {\n            console.log('组件已更新')\n        })\n\n        onUnmounted(() => {\n            console.log('组件即将卸载')\n        })\n    }\n}\n```\n\n## 代码复用\n\n组合式 API 的一个重要优势是更好的代码复用。我们可以创建自定义的组合函数：\n\n```javascript\n// composables/useCounter.js\nimport { ref } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n    const count = ref(initialValue)\n\n    const increment = () => count.value++\n    const decrement = () => count.value--\n    const reset = () => (count.value = initialValue)\n\n    return {\n        count,\n        increment,\n        decrement,\n        reset\n    }\n}\n\n// 在组件中使用\nimport { useCounter } from './composables/useCounter'\n\nexport default {\n    setup() {\n        const { count, increment, decrement, reset } = useCounter(10)\n\n        return {\n            count,\n            increment,\n            decrement,\n            reset\n        }\n    }\n}\n```\n\n## 与 TypeScript 的完美结合\n\n组合式 API 天生对 TypeScript 友好：\n\n```typescript\nimport { ref, Ref } from 'vue'\n\ninterface User {\n    id: number\n    name: string\n    email: string\n}\n\nexport default {\n    setup() {\n        const user: Ref<User | null> = ref(null)\n        const loading = ref(false)\n\n        const fetchUser = async (id: number): Promise<void> => {\n            loading.value = true\n            try {\n                const response = await fetch(`/api/users/${id}`)\n                user.value = await response.json()\n            } finally {\n                loading.value = false\n            }\n        }\n\n        return {\n            user,\n            loading,\n            fetchUser\n        }\n    }\n}\n```\n\n## 最佳实践\n\n1. **逻辑分组**: 将相关的响应式数据和方法放在一起\n2. **提取复用逻辑**: 将可复用的逻辑提取为组合函数\n3. **合理使用 ref 和 reactive**: 基本类型用 ref，对象用 reactive\n4. **避免解构 reactive**: 直接解构会失去响应性\n\n## 总结\n\nVue3 的组合式 API 为我们提供了更强大、更灵活的代码组织方式。它不仅解决了选项式 API 的一些限制，还为大型应用的开发提供了更好的支持。掌握组合式 API 是现代 Vue.js 开发的必备技能。\n\n---\n\n_更多 Vue3 相关内容，请关注我们的技术博客。_\n",
      "categoryId": 1,
      "categorySlug": "frontend",
      "categorySlugs": [
        "frontend",
        "vue"
      ],
      "tags": [
        "Vue3",
        "Composition API",
        "JavaScript"
      ],
      "author": "admin",
      "publishDate": "2024-01-15T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.634Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/vue3-composition-api-cover.jpg"
    },
    {
      "id": 2238124451,
      "title": "Node.js 性能优化实战",
      "slug": "nodejs-performance",
      "excerpt": "Node.js 作为高性能的服务器端 JavaScript 运行时，在正确使用的情况下能够提供出色的性能。但是，如果不注意一些关键的优化点，应用的性能可能会大打折扣。本文将分享一些实用的 Node.js 性能优化技巧。...",
      "content": "> 发布时间：2024-01-08  \n> 分类：后端开发 > Node.js  \n> 标签：Node.js, 性能优化, 后端开发\n\n## 引言\n\nNode.js 作为高性能的服务器端 JavaScript 运行时，在正确使用的情况下能够提供出色的性能。但是，如果不注意一些关键的优化点，应用的性能可能会大打折扣。本文将分享一些实用的 Node.js 性能优化技巧。\n\n## 性能监控\n\n在开始优化之前，我们需要建立性能监控体系：\n\n### 1. 使用 Performance Hooks\n\n```javascript\nconst { performance, PerformanceObserver } = require('perf_hooks')\n\nconst observer = new PerformanceObserver(list => {\n    const entries = list.getEntries()\n    entries.forEach(entry => {\n        console.log(`${entry.name}: ${entry.duration}ms`)\n    })\n})\n\nobserver.observe({ entryTypes: ['measure'] })\n\n// 测量代码执行时间\nperformance.mark('start-operation')\n// ... 执行一些操作\nperformance.mark('end-operation')\nperformance.measure('operation-duration', 'start-operation', 'end-operation')\n```\n\n### 2. 内存使用监控\n\n```javascript\n// 监控内存使用情况\nsetInterval(() => {\n    const memUsage = process.memoryUsage()\n    console.log({\n        rss: `${Math.round(memUsage.rss / 1024 / 1024)} MB`,\n        heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)} MB`,\n        heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)} MB`,\n        external: `${Math.round(memUsage.external / 1024 / 1024)} MB`\n    })\n}, 10000)\n```\n\n## 异步操作优化\n\n### 1. 避免阻塞事件循环\n\n```javascript\n// ❌ 错误：同步操作阻塞事件循环\nconst fs = require('fs')\nconst data = fs.readFileSync('large-file.txt')\n\n// ✅ 正确：使用异步操作\nconst fs = require('fs').promises\nconst data = await fs.readFile('large-file.txt')\n\n// ✅ 更好：使用流处理大文件\nconst fs = require('fs')\nconst stream = fs.createReadStream('large-file.txt')\n```\n\n### 2. 并发控制\n\n```javascript\nconst pLimit = require('p-limit')\n\n// 限制并发数量，避免资源耗尽\nconst limit = pLimit(5)\n\nconst urls = ['url1', 'url2', 'url3' /* ... 更多URL */]\n\nconst promises = urls.map(url => limit(() => fetch(url)))\n\nconst results = await Promise.all(promises)\n```\n\n## 内存管理优化\n\n### 1. 对象池化\n\n```javascript\nclass ObjectPool {\n    constructor(createFn, resetFn, initialSize = 10) {\n        this.createFn = createFn\n        this.resetFn = resetFn\n        this.pool = []\n\n        // 预先创建对象\n        for (let i = 0; i < initialSize; i++) {\n            this.pool.push(this.createFn())\n        }\n    }\n\n    acquire() {\n        return this.pool.length > 0 ? this.pool.pop() : this.createFn()\n    }\n\n    release(obj) {\n        this.resetFn(obj)\n        this.pool.push(obj)\n    }\n}\n\n// 使用示例\nconst bufferPool = new ObjectPool(\n    () => Buffer.alloc(1024),\n    buffer => buffer.fill(0),\n    50\n)\n```\n\n### 2. 避免内存泄漏\n\n```javascript\n// ❌ 内存泄漏：未清理的定时器\nconst timer = setInterval(() => {\n    // 一些操作\n}, 1000)\n\n// ✅ 正确：适时清理\nprocess.on('SIGTERM', () => {\n    clearInterval(timer)\n})\n\n// ❌ 内存泄漏：未移除的事件监听器\nconst EventEmitter = require('events')\nconst emitter = new EventEmitter()\n\nfunction handleEvent(data) {\n    // 处理事件\n}\n\nemitter.on('data', handleEvent)\n\n// ✅ 正确：移除监听器\nprocess.on('exit', () => {\n    emitter.removeListener('data', handleEvent)\n})\n```\n\n## 数据库优化\n\n### 1. 连接池管理\n\n```javascript\nconst mysql = require('mysql2')\n\n// 创建连接池\nconst pool = mysql.createPool({\n    host: 'localhost',\n    user: 'root',\n    password: 'password',\n    database: 'test',\n    connectionLimit: 10, // 限制连接数\n    queueLimit: 0, // 队列限制\n    acquireTimeout: 60000, // 获取连接超时\n    timeout: 60000, // 查询超时\n    reconnect: true // 自动重连\n})\n\n// 使用连接池\nconst promisePool = pool.promise()\n\nasync function getUser(id) {\n    const [rows] = await promisePool.execute('SELECT * FROM users WHERE id = ?', [id])\n    return rows[0]\n}\n```\n\n### 2. 查询优化\n\n```javascript\n// ❌ N+1 查询问题\nasync function getBooksWithAuthors() {\n    const books = await Book.findAll()\n    for (const book of books) {\n        book.author = await Author.findById(book.authorId)\n    }\n    return books\n}\n\n// ✅ 使用 JOIN 或批量查询\nasync function getBooksWithAuthors() {\n    return await Book.findAll({\n        include: [\n            {\n                model: Author,\n                as: 'author'\n            }\n        ]\n    })\n}\n```\n\n## 缓存策略\n\n### 1. 内存缓存\n\n```javascript\nconst LRU = require('lru-cache')\n\nconst cache = new LRU({\n    max: 1000, // 最大缓存项数\n    maxAge: 1000 * 60 * 10 // 10分钟过期\n})\n\nasync function getDataWithCache(key) {\n    // 先查缓存\n    let data = cache.get(key)\n    if (data) {\n        return data\n    }\n\n    // 缓存未命中，从数据库获取\n    data = await database.getData(key)\n    cache.set(key, data)\n\n    return data\n}\n```\n\n### 2. Redis 缓存\n\n```javascript\nconst redis = require('redis')\nconst client = redis.createClient()\n\nasync function getDataWithRedis(key) {\n    try {\n        // 尝试从 Redis 获取\n        const cachedData = await client.get(key)\n        if (cachedData) {\n            return JSON.parse(cachedData)\n        }\n\n        // 从数据库获取\n        const data = await database.getData(key)\n\n        // 缓存到 Redis（5分钟过期）\n        await client.setex(key, 300, JSON.stringify(data))\n\n        return data\n    } catch (error) {\n        console.error('Redis error:', error)\n        return await database.getData(key)\n    }\n}\n```\n\n## HTTP 请求优化\n\n### 1. Keep-Alive 连接\n\n```javascript\nconst http = require('http')\n\nconst agent = new http.Agent({\n    keepAlive: true,\n    keepAliveMsecs: 1000,\n    maxSockets: 50,\n    maxFreeSockets: 10\n})\n\n// 使用持久连接\nconst options = {\n    hostname: 'api.example.com',\n    port: 80,\n    path: '/data',\n    agent: agent\n}\n```\n\n### 2. 响应压缩\n\n```javascript\nconst express = require('express')\nconst compression = require('compression')\n\nconst app = express()\n\n// 启用 gzip 压缩\napp.use(\n    compression({\n        level: 6, // 压缩级别 (1-9)\n        threshold: 1024, // 大于1KB才压缩\n        filter: (req, res) => {\n            if (req.headers['x-no-compression']) {\n                return false\n            }\n            return compression.filter(req, res)\n        }\n    })\n)\n```\n\n## 集群模式\n\n```javascript\nconst cluster = require('cluster')\nconst numCPUs = require('os').cpus().length\n\nif (cluster.isMaster) {\n    console.log(`主进程 ${process.pid} 正在运行`)\n\n    // 为每个 CPU 核心创建工作进程\n    for (let i = 0; i < numCPUs; i++) {\n        cluster.fork()\n    }\n\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`工作进程 ${worker.process.pid} 已退出`)\n        cluster.fork() // 重新创建工作进程\n    })\n} else {\n    // 工作进程\n    require('./app.js')\n    console.log(`工作进程 ${process.pid} 已启动`)\n}\n```\n\n## 性能测试\n\n### 1. 压力测试\n\n```bash\n# 使用 ab 进行压力测试\nab -n 1000 -c 10 http://localhost:3000/api/users\n\n# 使用 wrk 进行更复杂的测试\nwrk -t12 -c400 -d30s http://localhost:3000/api/users\n```\n\n### 2. 性能分析\n\n```javascript\n// 使用 clinic.js 进行性能分析\n// 安装：npm install -g clinic\n// 使用：clinic doctor -- node app.js\n\n// 或使用内置的 profiler\nnode --prof app.js\nnode --prof-process isolate-*.log > processed.txt\n```\n\n## 最佳实践总结\n\n1. **监控优先**: 建立完善的性能监控体系\n2. **异步优化**: 避免阻塞操作，合理使用异步编程\n3. **内存管理**: 及时释放资源，避免内存泄漏\n4. **缓存策略**: 合理使用缓存减少计算和 I/O\n5. **数据库优化**: 使用连接池，优化查询\n6. **集群部署**: 充分利用多核 CPU\n7. **定期分析**: 使用工具定期分析性能瓶颈\n\n通过这些优化策略，可以显著提升 Node.js 应用的性能表现。记住，性能优化是一个持续的过程，需要根据实际情况不断调整和改进。\n\n---\n\n_关注更多 Node.js 后端开发技巧，提升你的服务器端开发能力。_\n",
      "categoryId": 2,
      "categorySlug": "backend",
      "categorySlugs": [
        "backend",
        "nodejs"
      ],
      "tags": [
        "Node.js",
        "性能优化",
        "后端开发"
      ],
      "author": "admin",
      "publishDate": "2024-01-08T00:00:00.000Z",
      "updateDate": "2025-08-25T03:17:57.612Z",
      "status": "published",
      "views": 0,
      "likes": 0,
      "comments": 0,
      "featured": false,
      "coverImage": "content/assets/images/nodejs-performance-cover.jpg"
    }
  ],
  "metadata": {
    "totalArticles": 6,
    "publishedArticles": 6,
    "draftArticles": 0,
    "lastUpdated": "2025-08-25T03:17:57.636Z",
    "version": "1.0.0",
    "generatedBy": "generate-article-index.js"
  }
}